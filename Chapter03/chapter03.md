# 3장. 애그리거트

## 📚 목차
- 3.1 애그리거트
- 3.2 애그리거트 루트
    - 3.2.1 도메인 규칙과 일관성
    - 3.2.2 애그리거트 루트의 기능 구현
    - 3.2.3 트랜잭션 범위
- 3.3 리포지터리와 애그리거트
- 3.4 ID를 이용한 애그리거트 참조
    - 3.4.1 ID를 이용한 참조와 조회 성능
- 3.5 애그리거트 간 집합 연관 
- 3.6 애그리거트를 팩토리로 사용하기

---

### 🔍 애그리거트
도메인 객체 모델이 복잡해지면 개별 구성요소 위주로 모델을 이해하게 되고 전반적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기 어려워진다.  
복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요한데, 그 방법이 바로 애그리거트다.  
애그리거트는 모델을 이해하는 데 도움을 줄 뿐만 아니라 일관성을 관리하는 기준도 된다. 모델을 보다 잘 이해할 수 있고 애그리거트 단위로 일관성을 관리하기 때문에, 애그리거트는 복잡한 도메인을 단순한 구조로 만들어준다. 복잡도가 낮아지는 만큼 도메인 기능을 확장하고 변경하는 데 필요한 노력(개발 시간)도 줄어든다.  
애그리거트는 관련된 모델을 하나로 모았기 때문에 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 갖는다.  
한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다. 애그리거트는 독립된 객체 군이며 각 애그리거트는 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다.

### 🔍 애그리거트 루트
애그리거트에 속한 모든 객체가 일관된상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데, 이 책임을 지는 것이 바로 애그리거트의 루트 엔티티이다. 루트 엔티티는 애그리거트의 대표 엔티티이다. 애그리거트에 속한 객체는 애그리거트 루트 엔티티에 직접 또는 간접적으로 속하게 된다.
- #### 도메인 규칙과 일관성
    애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다.  
    애그리거트 루트가 제공하는 메서드는 도메인 규칙에 따라 애그리거트에 속한 객체의 일관성이 깨지지 않도록 구현해야 한다.  
    애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안된다. 이것은 애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 깨는 원인이 된다. &rarr; 공개 set 메서드를 만들지 않고 밸류를 불변 타입으로 구현해야 한다.

- #### 애그리거트 루트의 기능 구현
    애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다.

- #### 트랜잭션 범위
    트랜잭션(데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위)의 범위는 작을 수록 좋다.  
    한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다.  
    한 트랜잭션에서 한 애그리거트만 수정한다는 것은 애그리거트에서 다른 애그리거트를 변경하지 않는다는 것을 의미한다. 
    애그리거트는 최대한 서로 독립적이어야 하는데 한 애그리거트가 다른 애그리거트의 기능에 의존하기 시작하면 애그리거트 간 결합도가 높아진다. 결합도가 높아지면 높아질수록 향후 수정 비용이 증가하므로 애그리거트에서 다른 애그리거트의 상태를 변경하지 말아야 한다.

### 🔍 리포지터리와 애그리거트
애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다.  
애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화해야한다.  
애그리거트의 상태가 변경되면 모든 변경을 원자적으로 저장소에 반영해야 한다. 그렇지 않으면 데이터 일관성이 깨지게 된다.

### 🔍 ID를 이용한 애그리거트 참조
애그리거트도 다른 애그리거트를 참조한다.  
애그리거트 간의 참조는 필드를 통해 쉽게 구현할 수 있다.
```java
public class Order{
    private Orderer orderer;
    ...
}

public class Orderer{
    private Member member;
    private String name;
    ...
}

public class Member{
    ...
}
```
하지만 필드를 이용한 애그리거트 참조는 다음 문제를 야기할 수 있다.

- 편한 탐색 오용  
    한 애그리거트에서 다른 애그리거트의 상태를 변경하는 것은 애그리거트 간의 의존 결합도를 높여서 결과적으로 애그리거트의 변경을 어렵게 만들기 때문에 한 애그리거트가 관리하는 범위는 자기 자신으로 한정해야 한다.
    그런데 애그리거트 내부에서 다른 애그리거트 객체에 접근할 수 있으면 다른 애그리거트를 수정하고자 하는 유혹에 빠지기 쉽다.

- 성능에 대한 고민  
    - 지연 로딩(lazy): 필요한 시점에 연관된 객체의 데이터를 불러오는 것   
    - 즉시 로딩(eager): 데이터를 조회할 때 연관된 모든 객체의 데이터까지 한번에 불러오는 것

- 확장 어려움  
    하위 도메인마다 서로 다른 종류의 데이터 저장소를 사용하게 되면 다른 애그리거트를 참조하기 위해 단일 기술을 사용할 수 없게 된다.

이런 세 가지 문제를 완화할 때 사용할 수 있는 것이 ID를 이용해서 다른 애그리거트를 참조하는 것이다.
```java
public class Order{
    private Orderer orderer;
    ...
}

public class Orderer{
    private MemberId memberId;
    private String name;
    ...
}

public class Member{
    private MemberId id;
    ...
}
```
ID 참조를 사용하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결된다. 이는 애그리거트의 경계를 명확히 하고 애그리거트 간 물리적인 연결을 제거하기 때문에 모델의 복잡도를 낮춰준다. 또한 애그리거트 간의 의존을 제거하므로 응집도를 높여주는 효과도 있다.  
구현 복잡도도 낮아진다. 다른 애그리거트를 직접 참조하지 않으므로 애그리거트 간 참조를 어떤 방식으로 할지 고민하지 않아도 된다.  
외부 애그리거트를 직접 참조하지 않기 때문에 한 애그리거트에서 다른 애그리거트의 상태를 변경할 수 없다.  
애그리거트별로 다른 구현 기술을 사용하는 것도 가능해진다.

- #### ID를 이용한 잠조와 조회 성능
    다른 애그리거트를 ID로 참조하면 참조하는 여러 애그리거트를 읽을 때 조회 속도가 문제 될 수 있다.
    ID를 이용한 애그리거트 참조는 지연 로딩과 같은 효과를 만드는 데 지연 로딩과 관련된 대표적인 문제가 N+1 조회 문제(조회 대상이 N개일 때 N개를 읽어오는 한 번의 쿼리와 연관된 데이터를 읽어오는 쿼리를 N번 실행)이다.  
    ID 참조 방식을 사용하면서 N+1 조회와 같은 문제가 발생하지 않도록 하려면 조회 전용 쿼리를 사용하면 된다.
