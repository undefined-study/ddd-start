# 8장. 애그리거트 트랜잭션 관리

## 📚 목차
- 8.1 애그리거트와 트랜잭션
- 8.2 선점 잠금
- 8.2.1 선점 잠금과 교착 상태
- 8.3 비선점 잠금
- 8.3.1 강제 버전 증가
- 8.4 오프라인 선점 잠금
- 8.4.1 오프라인 선점 잠금을 위한 Lock Manager 인터페이스와 관련 클래스
- 8.4.2 DB를 이용한 LockManager 구현

---

### 🔍 애그리거트와 트랜잭션
한 애그리거트를 두 사용자가 동시에 변경할 때 트랜잭션이 필요하다.  
애그리거트에 대해 사용할 수 있는 대표적인 트랜잭션 처리 방식에는 선점 잠금과 비선점 잠금의 두 가지 방식이 있다.

### 🔍 선점 잠금
![image](/resources/08-1.png)
선점 잠금은 먼저 애그리거트를 구한 스레드가 애리거트 사용이 끝날 때지 다른 스레드가 해당 애그리거트를 수정하지 못하게 막는 방식이다.  
한 스레드가 애리거트를 구하고 수정하는 동안 다른 스레드가 수정할 수 없으므로 동시에 애그리거트를 수정할 때 발생하는 데이터 충돌 문제를 해소할 수 있다.  
선점 잠금은 보통 DBMS가 제공하는 행단위 잠금을 사용해서 구현한다.  
- #### 선점 잠금과 교착 상태
    선점 잠금 기능을 사용할 때는 잠금 순서에 따른 교착 상태가 발생하지 않도록 주의해야 한다.  
    선점 잠금에 따른 교착 상태는 상대적으로 사용자 수가 많을 때 발생할 가능성이 높고, 사용자 수가 많아지면 교착 상태에 빠지는 스레드는 더 빠르게 증가한다. 더 많은 스레드가 교착 상태에 빠질 수록 시스템은 아무것도 할 수 없는 상태가 된다.  
    이런 문제가 발생하지 않도록 하려면 잠금을 구할 때 최대 대기 시간을 지정해야 한다.

### 🔍 비선점 잠금
![image](/resources/08-2.png)
비선점 잠금은 동시에 접근하는 것을 막는 대신 변경한 데이터를 실제 DBMS에 반영하는 시점에 변경 가능 여부를 확인하는 방식이다.  
비선점 잠금을 구현하려면 애그리거트에 버전으로 사용할 숫자 타입 프로퍼티를 추가해야 한다.  
- #### 강제 버전 증가
    루트 엔티티의 값이 바뀌지 않았더라도 애리거트의 구성요소 중 일부 값이 바뀌면 논리적으로 그 애리거트는 바뀐 것이다.  
    따라서 애그리거트 내에 어떤 구성요소의 상태가 바뀌면 루트 애리거트의 버전 값이 증가해야 비선점 잠금이 올바르게 동작한다.

### 🔍 오프라인 선점 잠금
단일 트랜잭션에서 동시 변경을 막는 선점 잠금 방식과 달리 오프라인 선점 잠금은 여러 트랜잭션에 걸쳐 동시 변경을 막는다.  
첫 번째 트랜잭션을 시작할 때 오프라인 잠금을 선점하고, 마지막 트랜잭션에서 잠금을 해제한다.  
잠금을 해제하기 전까지 다른 사용자는 잠금을 구할 수 없다.  
따라서 오프라인 선점 방식은 잠금 유효 시간을 가져야하며, 일정 주기로 유효 시간을 증가시켜야 한다.