# 4장. 리포지터리와 모델 구현

## 📚 목차
- 4.1 JPA를 이용한 리포지터리 구현
    - 4.1.1 모듈 위치
    - 4.1.2 리포지터리 기본 기능 구현
- 4.2 스프링 데이터 JPA를 이용한 리포지터리 구현
- 4.3 매핑 구현
    - 4.3.1 엔티티와 밸류 기본 매핑 구현
    - 4.3.2 기본 생성자
    - 4.3.3 필드 접근 방식 사용
    - 4.3.4 AttributeConverter를 이용한 밸류 매핑 처리
    - 4.3.5 밸류 컬렉션: 별도 테이블 매핑
    - 4.3.6 밸류 컬렉션: 한 개 칼럼 매핑
    - 4.3.7 밸류를 이용한 ID 매핑
    - 4.3.8 별도 테이블에 저장하는 밸류 매핑
    - 4.3.9 밸류 컬렉션을 @Entity로 매핑하기
    - 4.3.10 ID 참조와 조인 테이블을 이용한 단방향 M-N 매핑
- 4.4 애그리거트 로딩 전략
- 4.5 애그리거트의 영속성 전파
- 4.6 식별자 생성 기능
- 4.7 도메인 구현과 DIP

---

### 🔍 JPA를 이용한 리포지터리 구현
- #### 모듈 위치
    리포지터리 인터페이스는 도메인 영역에 속하고, 구현 클래스는 인프라스트럭처 영역에 속한다.
    ![image](/resources/04-1.png)

### 🔍 애그리거트 로딩 전략
애그리거트에 속한 객체는 모두 모여야 완전한 하나가 된다.  
조회 시점에 애그리거트를 완전한 상태가 되도록 하려면 애그리거트 루트에서 연관 매핑의 조회 방식을 즉시 로딩(Eager)으로 설정하면 된다.  
즉시 로딩 방식으로 설정하면 애그리거트 루트를 로딩하는 시점에 애그리거트에 속한 모든 객체를 함게 로딩할 수 있는 장점이 있지만 이것이 항상 좋은 것은 아니다.  
조회 되는 데이터 개수가 많아지면 즉시 로딩 방식을 사용할 때 성능을 검토해 봐야 한다.  
애그리거트는 개념적으로 하나여야 하지만 루트 엔티티를 로딩하는 시점에 애그리거트에 속한 객체를 모두 로딩해야 하는 것은 아니다. 필요한 시점에 필요한 구성 요소만 로딩해도 문제가 되지 않는다.  
따라서 애그리거트 내의 모든 연관을 즉시 로딩으로 설정할 필요는 없다.  
지연 로딩은 동작 방식이 항상 동일하기 때문에 즉시 로딩처럼 경우의 수를 따질 필요가 없는 장점이 있다. 물론 지연 로딩은 즉시 로딩보다 쿼리 실행 횟수가 많아질 가능성이 더 높다.  
무조건 즉시 로딩이나 지연 로딩으로만 설정하기보다는 애그리거트에 맞게 즉시 로딩과 지연 로딩을 선택해야 한다.

### 🔍 애그리거트의 영속성 전파
애그리거트가 완전한 상태여야 한다는 것은 애그리거트 루트를 조회할 때뿐만 아니라 저장하고 삭제할 때도 하나로 처리해야 함을 의미한다.

### 🔍 도메인 구현과 DIP
DIP에 따르면 도메인 모델은 구현 기술인 JPA에 의존하지 말아야 하고, 리포지터리 인터페이스도 도메인 패키지에 위치하면 안된다.
구현 기술에 대한 의존을 없애려면 구현 클래스를 인프라에 위치시켜야 한다.
DIP를 적용하는 주된 이유는 저수준 구현이 변경되더라도 고수준이 영향을 받지 않도록 하기 위함이기 때문이다. 그러나 리포지터리와 도메인 모델의 구현 기술은 거의 바뀌지 않는다.
DIP를 완벽하게 지키면 좋겠지만 변경이 거의 없는 상황에서 변경을 미리 대비하는 것은 과할 수 있기 때문에 어느 정도 타협을 하는 것은 합리적이다.